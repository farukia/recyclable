<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>The Recycle Disciple</title>
    <link href="style.css" rel="stylesheet" type="text/css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
  </head>
  <body>
    <!-- https://teachablemachine.withgoogle.com/models/fgxQHUQ3z/-->
    <div class="title">The Recycle Disciple</div>

    <div class="loader" id="loader"></div> 

    <!-- Start button loads the model, sets up the webcam, and begins predictions -->
    <button type="button" onclick="init()">Start</button>
    <!-- Toggle Camera button switches between front and back cameras -->
    <button type="button" onclick="toggleCamera()">Toggle Camera</button>

    <div id="webcam-container"></div>
    <div id="label-container"></div>
    <p id="text" style="text-align:center;"></p>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>

    <script type="text/javascript">
      // URL of the Teachable Machine model
      const URL = "https://teachablemachine.withgoogle.com/models/Q0vMyAAez/";

      // Feedback messages for each prediction class
      var feedback = [
        "PET 1 - Can be recycled at curbside or your local recycling center",
        "HDPE 2 - Can be recycled at curbside or your local recycling center. Lids may be replaced.",
        "PVC 3 - These are generally not recyclable. If you wish to recycle it, check with your local recycling center.",
        "LDPE 4 - These are generally not recyclable. If you wish to recycle it, check with your local recycling center.",
        "PP 5 - These are generaly recyclable.",
        "PS 6 - These are generally not recyclable. If you wish to recycle it, check with your local recycling center.",
        "Other 7 - These are generally not recyclable. If you wish to recycle it, check with your local recycling center."
      ];

      let model, webcam, labelContainer, maxPredictions;

      // Global variable to keep track of camera mode; defaults to front camera
      let currentFacingMode = "user";

      // Utility function that returns the index of the maximum value in an array.
      function indexOfMax(arr) {
        if (arr.length === 0) return -1;
        let maxIndex = 0;
        for (let i = 1; i < arr.length; i++) {
          if (arr[i] > arr[maxIndex]) {
            maxIndex = i;
          }
        }
        return maxIndex;
      }

      // Initialize the Teachable Machine model and the webcam.
      async function init() {
        const modelURL = URL + "model.json";
        const metadataURL = URL + "metadata.json";

        document.getElementById("loader").style.display = "block";
        document.getElementById("text").innerHTML = "Loading...";

        // Load the model and metadata.
        model = await tmImage.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();

        document.getElementById("loader").style.display = "none";

        // Setup the webcam with the current facing mode.
        const flip = true; // whether to flip the webcam video
        webcam = new tmImage.Webcam(200, 200, flip);
        // Pass the facingMode constraint to choose the correct camera.
        // Note: This assumes the tmImage.Webcam.setup() accepts constraints.
        await webcam.setup({ video: { facingMode: { exact: currentFacingMode } } });
        await webcam.play();

        // Start the prediction loop.
        window.requestAnimationFrame(loop);

        // Append the webcam canvas to the DOM.
        document.getElementById("webcam-container").innerHTML = "";
        document.getElementById("webcam-container").appendChild(webcam.canvas);

        labelContainer = document.getElementById("label-container");
        // Create elements for class labels (if you wish to display them).
        for (let i = 0; i < maxPredictions; i++) {
          labelContainer.appendChild(document.createElement("div"));
        }
      }

      // Main prediction loop.
      async function loop() {
        webcam.update(); // update the webcam frame
        await predict();
        window.requestAnimationFrame(loop);
      }

      // Run the webcam image through the model for prediction.
      async function predict() {
        const prediction = await model.predict(webcam.canvas);
        // (Optional) You can update your labelContainer here with class names and probabilities.
        // For example:
        // for (let i = 0; i < maxPredictions; i++) {
        //   labelContainer.childNodes[i].innerHTML = prediction[i].className + ": " + prediction[i].probability.toFixed(2);
        // }

        // Build an array of probabilities (formatted to two decimal places).
        var probabilities = [];
        for (let i = 0; i < 7; i++) {
          probabilities.push(prediction[i].probability.toFixed(2));
        }

        // Determine which prediction has the highest probability.
        var max = indexOfMax(probabilities);
        // Display the corresponding feedback message.
        if (max === 0) {
          document.getElementById("text").innerHTML = feedback[0];
        } else if (max === 1) {
          document.getElementById("text").innerHTML = feedback[1];
        } else if (max === 2) {
          document.getElementById("text").innerHTML = feedback[2];
        } else if (max === 3) {
          document.getElementById("text").innerHTML = feedback[3];
        } else if (max === 4) {
          document.getElementById("text").innerHTML = feedback[4];
        } else if (max === 5) {
          document.getElementById("text").innerHTML = feedback[5];
        } else if (max === 6) {
          document.getElementById("text").innerHTML = feedback[6];
        }
      }

      // Toggle the camera from front ("user") to back ("environment") or vice versa.
      async function toggleCamera() {
        // Toggle facing mode.
        currentFacingMode = currentFacingMode === "user" ? "environment" : "user";

        // Stop the current webcam stream.
        if (webcam && webcam.stop) {
          webcam.stop();
        }

        // Clear the current webcam display.
        document.getElementById("webcam-container").innerHTML = "";

        // Create a new webcam instance.
        webcam = new tmImage.Webcam(200, 200, true);
        try {
          // Attempt to setup the webcam with the new facing mode.
          await webcam.setup({ video: { facingMode: { exact: currentFacingMode } } });
        } catch (error) {
          console.error("Facing mode constraint failed, trying without exact constraint:", error);
          // Fallback: try without the exact constraint.
          await webcam.setup({ video: { facingMode: currentFacingMode } });
        }
        await webcam.play();

        // Re-append the webcam canvas.
        document.getElementById("webcam-container").appendChild(webcam.canvas);
      }
    </script>
  </body>
</html>
